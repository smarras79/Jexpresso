var documenterSearchIndex = {"docs":
[{"location":"features/performance/#Performance-of-Jexpresso-on-CPU","page":"Performance","title":"Performance of Jexpresso on CPU","text":"Jexpresso was coded to minimize memory access and speed. With the goal of making Jexpresso a community solver of PDEs, it was mandatory to make it at least as fast as a compiled-language code. Jexpresso was benchmarked against a legacy code for atmospheric modeling written in Fortran 90/95/modern Fortran. The two software packages were compared on the same CPU core.\n\nThe code speed was measured for the solution of the compressible Naver-Stokes equations with gravity\n\nbf q=beginbmatrix\nrho \nrho u\nrho v\nrho theta\nendbmatrixquad bf F1=beginbmatrix\nrho u\nrho u^2 + p\nrho u v\nrho u theta\nendbmatrixquad bf F2=beginbmatrix\nrho v\nrho v u\nrho v^2 + p\nrho v theta\nendbmatrixquad bf S=beginbmatrix\n0\n0\n-rho g\n0\nendbmatrixquad munabla^2bf q=mubeginbmatrix\n0\nu_xx + u_zz\nv_xx + v_zz\ntheta_xx + theta_zz\nendbmatrix","category":"section"},{"location":"features/performance/#Speed","page":"Performance","title":"Speed","text":"Table: Wall clock time of Jexpresso vs a legacy F90/Modern Fortran code for numerical weather prediction. Simulated 100 seconds of a rising-thermal-bubble test. The name of the time integrators may be different for the two codes so that the notation jexpresso/numa is used to indicate both. The wall clock times are to be taken with a pm 02 due to a small variability from one simulation to the next one. \n\nTiming was measured using Julia 1.9.3 on a Macbook Air M1 2020, with macOS Big Sur Version 11.6.\n\nTime integrator max Delta t (s) Effective resolution (m) Order colorredJexpresso (s) colorblueF90 (s)\nSSPRK53 0.3 \" \" 9.00 10.53\nSSPRK33 0.2 125times 125 4 9.75 9.2028\nSSPRK54 0.4 \" \" 10.47 NA\nDP5 (Dormand-Prince RK54) 0.6 \" \" 19.80 NA\nSSPRK73 0.4 \" \" 12.95 NA\nSSPRK104 0.6 \" \" 12.50 NA\nCarpenterKennedy2N54 0.4 \" \" 10.57 NA\nTsit5 2.0 (adaptive) \" \" 19.08 NA","category":"section"},{"location":"features/performance/#Mass-conservation","page":"Performance","title":"Mass conservation","text":"Table: Mass conservation of the advective vs flux forms of the equations and sensitivity to the time integrators of  DifferentialEquations.jl for the RTB at t = 1000 s viscous. Results are for inexact integration.\n\nTime integrator Advection form Flux from\nMSRK5 7.818062181220379e-16 3.9090310906101895e-16\nSSPRK53 7.622610626689869e-15 1.9545155453050947e-16\nSSPRK33 5.081740417793246e-15 1.1727093271830568e-15","category":"section"},{"location":"tutorials/newcase/#Tutorial:-create-a-case-from-scratch:","page":"Tutorial: create a case from scratch:","title":"Tutorial: create a case from scratch:","text":"This tutorial guides you through the process of creating a new physical problem from scratch. We will cover the necessary setup and command execution.","category":"section"},{"location":"tutorials/newcase/#Prerequisites","page":"Tutorial: create a case from scratch:","title":"Prerequisites","text":"Before starting, ensure you have the following:\n\nJulia Installation: You need to have Julia installed on your system. You can download it from the official Julia website: https://julialang.org/downloads/\nJexpresso Repository: The Jexpresso.jl framework needs to be accessible. This tutorial assumes you have the repository cloned locally. If not, you can clone it using Git:   bash   git clone https://github.com/smarras79/Jexpresso.git   bash   git clone https://github.com/smarras79/JexpressoMeshes.git   bash   cd Jexpresso   bash   ln -s ../JexpressoMeshes/meshes .","category":"section"},{"location":"tutorials/newcase/#Creating-a-New-Problem-called-Hello-in-Jexpresso/problems/equations/CompEuler/","page":"Tutorial: create a case from scratch:","title":"Creating a New Problem called Hello in Jexpresso/problems/equations/CompEuler/","text":"cd problems/equations/CompEuler\n\nStep2: Create a New Directory for Your Case\n\nmkdir Hello\n\nStep3: Enter the New Case Directory\n\ncd Hello\n\nStep4: Copy Essential Files\n\nCopy the generic solver files from the theta directory into your new case directory. These files provide the basic structure for your simulation.\n\ncp ../theta/*.jl .\n\nStep5: Configure Initial Conditions in initialize.jl\n\nOpen the initialize.jl file in a text editor. In this file, you will need to define and initialize the solution array q. The structure of q depends on the dimensionality of your problem and the number of conserved variables (e.g., density, momentum components, energy).","category":"section"},{"location":"tutorials/newcase/#Example-of-initialization-for-the-2D-Euler-equations-density-(rho),-momentum-(rho-u),-and-potential-temperature","page":"Tutorial: create a case from scratch:","title":"Example of initialization for the 2D Euler equations density (rho), momentum (rho u), and potential temperature","text":"Open initialize.jl: (ex.Jepresso/problems/equations/CompEuler/theta/initialize.jl)\n\nfunction initialize(SD::NSD_2D, \n                    PT, \n                    mesh::St_mesh, \n                    inputs::Dict, \n                    OUTPUT_DIR::String, \n                    TFloat)\n\nDefine the solution variables and, optional, the array of output variables. \n\nThe length of qvars will define the size of the problem.  However, the optional array qoutvars can be longer or shorter and is only used by the output writing function. If qoutvars is not defined, the the default output variables coincide with qvars.\n\n    qvars    = [\"ρ\", \"ρu\", \"ρv\", \"ρθ\"]\n    qoutvars = [\"ρ\", \"u\", \"w\", \"θ\", \"p\"]\n\nAllocate space for the solution array:\n\n    q = define_q(SD, \n                 mesh.nelem, \n                 mesh.npoin, \n                 mesh.ngl, \n                 qvars, \n                 TFloat, \n                 inputs[:backend]; \n                 neqs=length(qvars), \n                 qoutvars=qoutvars)","category":"section"},{"location":"tutorials/newcase/#Now-initialize:","page":"Tutorial: create a case from scratch:","title":"Now initialize:","text":"For example, a minimal version of Jepresso/problems/equations/CompEuler/theta/initialize.jl: may looks like this:\n\n    if (inputs[:backend] == CPU())    \n        PhysConst = PhysicalConst{Float64}()\n        \n            xc = 0.0; yc = 2500.0\n        \n            for ip = 1:mesh.npoin\n\n                x, y = mesh.x[ip], mesh.y[ip]\n                r = sqrt( (x - xc)^2 + (y - yc)^2 )\n            \n                θ = 300\n                p = 100000\n                ρ = 1.25\n\n                u = 0.0\n                v = 0.0\n\n                q.qn[ip,1] = ρ\n                q.qn[ip,2] = ρ*u\n                q.qn[ip,3] = ρ*v\n                q.qn[ip,4] = ρ*θ\n                q.qn[ip,end] = p\n\n            end\n        end\n    return q\nend\n\nWARNING: refer to a proper working code rather than the simplified version above. The one above was given as an example of what an initialization file may look like.","category":"section"},{"location":"tutorials/newcase/#Add-the-fluxes-for-the-equations-that-you-are-solving:","page":"Tutorial: create a case from scratch:","title":"Add the fluxes for the equations that you are solving:","text":"If we were to solve the 2D Euler equations of compressible flows with gravity, where q and the fluxes are defined as\n\nbf q=beginbmatrix\nrho \nrho u\nrho v\nrho theta\nendbmatrixquad bf F1=beginbmatrix\nrho u\nrho u^2 + p\nrho u v\nrho u theta\nendbmatrixquad bf F2=beginbmatrix\nrho v\nrho v u\nrho v^2 + p\nrho v theta\nendbmatrixquad bf S=beginbmatrix\n0\n0\n-rho g\n0\nendbmatrixquad munabla^2bf q=mubeginbmatrix\n0\nu_xx + u_zz\nv_xx + v_zz\ntheta_xx + theta_zz\nendbmatrix\n\nthen the function user_flux.jl is imply:\n\nfunction user_flux!(F, \n                    G, \n                    SD::NSD_2D, \n                    q, qe,\n                    mesh::St_mesh, \n                    ::CL, \n                    ::TOTAL; \n                    neqs=4, ip=1)\n\n    PhysConst = PhysicalConst{Float64}()\n    \n    ρ  = q[1]\n    ρu = q[2]\n    ρv = q[3]\n    ρθ = q[4]\n    θ  = ρθ/ρ\n    u  = ρu/ρ\n    v  = ρv/ρ\n    Pressure = perfectGasLaw_ρθtoP(PhysConst, ρ=ρ, θ=θ)\n    \n    F[1] = ρu\n    F[2] = ρu*u .+ Pressure\n    F[3] = ρv*u\n    F[4] = ρθ*u\n\n    G[1] = ρv\n    G[2] = ρu*v\n    G[3] = ρv*v .+ Pressure\n    G[4] = ρθ*v\nend\n\nNotice how there are no loops and the F and G are exactly defined as you'd write them on paper.","category":"section"},{"location":"tutorials/newcase/#Add-the-sources:","page":"Tutorial: create a case from scratch:","title":"Add the sources:","text":"Similarly, you handle the source through user_source.jl.","category":"section"},{"location":"tutorials/newcase/#Outouts:","page":"Tutorial: create a case from scratch:","title":"Outouts:","text":"By default, the output is written for the solution variables.  Follow the output tutorial here","category":"section"},{"location":"tutorials/newcase/#Now-run-the-new-case:","page":"Tutorial: create a case from scratch:","title":"Now run the new case:","text":"push!(empty!(ARGS), \"CompEuler\", \"Hello\");\ninclude(\"./src/Jexpresso.jl\")","category":"section"},{"location":"features/best-practices/#Best-practices-to-prevent-performance-deterioration","page":"Best practices","title":"Best practices to prevent performance deterioration","text":"This section wants to give some non-comprehensive best-practice suggestions to prevent performance deterioration when new code is added or old code is modified.\n\nClearly, more thorough information on Julia performance can be found online, but here we report those that we learned during the implementation of Jexpresso.","category":"section"},{"location":"features/best-practices/#Vectors-vs-tuples:","page":"Best practices","title":"Vectors vs tuples:","text":"do not abuse tuples. For example, the user_inputs.jl files that conbtain the setups for each problem case activate artificial diffusion as follows:\n\n        :lvisc            => true,\n        :ivisc_equations  => [1, 2, 3, 4],\n        :μ                => [0.0, 20.0, 20.0, 60.0],\n\nwhere the value of the diffusivity coefficient (μ) is given for each equation (ivisc_equations).\n\nNotice that these are stored as arrays ([...]). While the code still works if we used tuples instead ((...)), performance would drasticially deterioriate due to unnecessary allocation at runtime. Notice that tuples are perfectly fine to be used, as long as they are used where really needed.","category":"section"},{"location":"Jexpresso/#Jexpresso","page":"Jexpresso","title":"Jexpresso","text":"","category":"section"},{"location":"Jexpresso/#Jexpresso","page":"Jexpresso","title":"Jexpresso","text":"A research software for the numerical solution of a system of an arbitrary number of conservation laws using continuous spectral elements. DISCLAIMER: this is WIP and only 2D is being maintained until parallelization is complete.\n\nIf you are interested in contributing, please get in touch. Simone Marras, Yassine Tissaoui\n\n\n\n\n\n","category":"module"},{"location":"tutorials/define_output_variables/#Tutorial:-define-the-output-variables:","page":"Tutorial: define the output variables:","title":"Tutorial: define the output variables:","text":"This tutorial explains how to setup the array of output variables and extract them from the solution variables.","category":"section"},{"location":"tutorials/define_output_variables/#Step-1:-Go-to-your-problem-directory:","page":"Tutorial: define the output variables:","title":"Step 1: Go to your problem directory:","text":"cd problems/equations/CompEuler/YOUR_PROBLEM","category":"section"},{"location":"tutorials/define_output_variables/#Step-2:-Open-initialize.jl:","page":"Tutorial: define the output variables:","title":"Step 2: Open initialize.jl:","text":"If not already done so, define the optional array of output variables qoutvars right after the solution array q.\n\nThe length of qoutvars and qvars do not have to be the same. In fact, qoutvars could possibly be way longer than qvars.\n\nIf qoutvars is not defined, the the default output variables coincide with qvars. Inside initialize.jl you may have:\n\n    qvars    = [\"ρ\", \"ρu\", \"ρv\", \"ρθ\"]\n    qoutvars = [\"ρ\", \"u\", \"w\", \"θ\", \"p\"]\n\nIf qoutvars had not been previously used, remember to add it to the parameter argument of the call to define_q as shown below\n\n    q = define_q(SD, \n                 mesh.nelem, \n                 mesh.npoin, \n                 mesh.ngl, \n                 qvars, \n                 TFloat, \n                 inputs[:backend]; \n                 neqs=length(qvars), \n                 qoutvars=qoutvars)\n    ```\n\n## Step 3: Extract the outout vartiables from the solutions:\nOpen `user_primitives,jl` and use `function user_out!` to derive the outpout vars from the unknown vector. \n\nHere an example to obtain some primitive quantities from the solution array `qvars=[ρ, ρu, ρv, ρθ]` if `qoutvars = [\"ρ\", \"u\", \"w\", \"θ\", \"p\"]` was defined in `initialize.jl` as explained above:\n\n\nfunction user_uout!(uout, u, qe, )\n\nPhysConst = PhysicalConst{Float64}()\n\nuout[1] = u[1]       #ρ\nuout[2] = u[2]/u[1]  #u\nuout[3] = u[3]/u[1]  #v\nuout[4] = u[4]/u[1]  #θ\n\np = perfectGasLaw_ρθtoP(PhysConst, ρ=uout[1], θ=uout[4])\nuout[end] = p\n\nend\n\n```\n\nIMPORATANT NOTICE: the dimension of uout is that of outvars defined in initialize.jl. uout in user_uout! cannot be bigger than qoutvars!\n\nLink to an example of user_primitives.jl.","category":"section"},{"location":"tutorials/user_inputs/#user_inputs.jl","page":"User inputs","title":"user_inputs.jl","text":"Every user-defined problem has its own namelist/input file called user_inputs.jl. A sample userinputs.jl file with all possible entries (notice that not all entries are necessary). Use # to comment a line. When a line is commented or not explicitaly give, default values will be used.  The entries (with default values) are defined in `src/io/modinputs.jl`.\n\nfunction user_inputs()\n    \n    inputs = Dict(\n        #---------------------------------------------------------------------------\n        # User define your inputs below: the order doesn't matter\n        #---------------------------------------------------------------------------\n        :ode_solver              => SSPRK54(), #From the suite of solvers of DifferentialEquations.jl\n        :Δt                      => 0.4,\n        :tinit                   => 0.0,\n        :tend                    => 1000.0,\n        #:tinit                  => 100.0,\n        #:tend                   => 1000.0,\n        #:lrestart               => true,\n        #:restart_input_file_path => \"./output/CompEuler/theta/\",\n        :diagnostics_at_times    => (0:100:1000),\n        :lsource                 => true, \n        #:backend                => MetalBackend(),\n        #:SOL_VARS_TYPE          => PERT(), #TOTAL() is default\n        #---------------------------------------------------------------------------\n        #Integration and quadrature properties\n        #---------------------------------------------------------------------------\n        :interpolation_nodes     =>\"lgl\",\n        :nop                     => 4,      # Polynomial order\n        #---------------------------------------------------------------------------\n        # Physical parameters/constants:\n        #---------------------------------------------------------------------------\n        :lvisc                   => true,                   #false by default\n        :ivisc_equations         => [1, 2, 3, 4],           # use [], not ()!\n        :μ                       => [0.0, 20.0, 20.0, 60.0], # use [], not ()!\n        #---------------------------------------------------------------------------\n        # Filter parameters\n        #---------------------------------------------------------------------------\n        #:lfilter                => true,\n        #:mu_x                   => 0.01,\n        #:mu_y                   => 0.01,\n        #:filter_type            => \"erf\",\n\t#---------------------------------------------------------------------------\n        # Mesh paramters and files:\n        #---------------------------------------------------------------------------\n        :lread_gmsh              => true, #If false, a 1D problem will be enforced\n        :gmsh_filename           => \"./meshes/gmsh_grids/hexa_TFI_RTB20x20.msh\",\n\t#---------------------------------------------------------------------------\n\t# init_refinement\n\t#---------------------------------------------------------------------------\n\t# When true this takes the input mesh (which can be as coarse as you'd like)\n\t# and statically refine it as many times as the value of :init_refine_lvl\n\t# E.g. Given a grid of 20x10x3 elements, \n\t#  :init_refine_lvl => 1 will generate a 40x20x6 grid (octree)\n\t#---------------------------------------------------------------------------\n\t:linitial_refine         => false,\n\t:init_refine_lvl         => 1,\n\t#---------------------------------------------------------------------------\n        # AMR: Adaptive Mesh Refinement (different from initial_refinement)\n        #---------------------------------------------------------------------------\n        :ladapt                  => false,\n        :amr_freq                => 200, #AMR is triggered every :amr_freq steps\n        :amr_max_level           => 2,   #levels of oct/quadtree subdivisions\n\t#---------------------------------------------------------------------------\n        # Plotting parameters\n        #---------------------------------------------------------------------------\n        :outformat               => \"vtk\",\n        :loverwrite_output       => true,\n        :lwrite_initial          => false,\n        :output_dir              => \"./output\",\n        :loutput_pert            => true,  #this is only implemented for VTK for now\n        #---------------------------------------------------------------------------\n    ) #Dict\n    #---------------------------------------------------------------------------\n    # END User define your inputs below: the order doesn't matter\n    #---------------------------------------------------------------------------\n\n    return inputs\n    \nend","category":"section"},{"location":"tutorials/running-jexpresso/#Setup-with-CPUs","page":"-","title":"Setup with CPUs","text":">> cd $JEXPRESSO_HOME\n>> julia --project=. -e \"using Pkg; Pkg.instantiate(); Pkg.API.precompile()\"\n\nfollowed by the following:\n\nPush problem name to ARGS You need to do this only when you run a new problem\n\npush!(empty!(ARGS), EQUATIONS::String, EQUATIONS_CASE_NAME::String);\ninclude(\"./src/Jexpresso.jl\")\n\nPROBLEMNAME is the name of your problem directory as JEXPRESSO/problems/equations/problemname\nPROBLEMCASENAME is the name of the subdirectory containing the specific setup that you want to run: \n\nThe path would look like  $JEXPRESSO/problems/equations/PROBLEM_NAME/PROBLEM_CASE_NAME\n\nSome examples available in this branch:\n\nExample 1: to solve the 2D Euler equations with buyoancy and two passive tracers defined in problems/equations/CompEuler/thetaTracers  you would do the following:\n\npush!(empty!(ARGS), \"CompEuler\", \"thetaTracers\");\ninclude(\"./src/Jexpresso.jl\")\n\nExample 2: to solve the 3D Euler equations with buyoancy defined in problems/equations/CompEuler/3d you would do the following:\n\npush!(empty!(ARGS), \"CompEuler\", \"3d\");\ninclude(\"./src/Jexpresso.jl\")","category":"section"},{"location":"tutorials/running-jexpresso/#Setup-and-Run-with-MPI","page":"-","title":"Setup and Run with MPI","text":"JEXPRESSO supports parallel execution using either OpenMPI or MPICH. Follow these steps to configure and run with your preferred MPI implementation.","category":"section"},{"location":"tutorials/running-jexpresso/#1.-Install-MPI-Implementation","page":"-","title":"1. Install MPI Implementation","text":"Choose either OpenMPI or MPICH:","category":"section"},{"location":"tutorials/running-jexpresso/#OpenMPI-Installation","page":"-","title":"OpenMPI Installation","text":"# Ubuntu/Debian\nsudo apt install libopenmpi-dev openmpi-bin\n\n# macOS (Homebrew)\nbrew install open-mpi\n\n# Verify installation\nmpiexec --version","category":"section"},{"location":"tutorials/running-jexpresso/#MPICH-Installation","page":"-","title":"MPICH Installation","text":"# Ubuntu/Debian\nsudo apt install mpich libmpich-dev\n\n# macOS (Homebrew) \nbrew install mpich\n\n# Verify installation\nmpiexec --version","category":"section"},{"location":"tutorials/running-jexpresso/#2.-Configure-MPI-Preferences","page":"-","title":"2. Configure MPI Preferences","text":"","category":"section"},{"location":"tutorials/running-jexpresso/#Automatic-Configuration-(Default-Path)","page":"-","title":"Automatic Configuration (Default Path)","text":"Use this command when MPI (OpenMPI/MPICH) is installed in standard system paths (/usr/bin, /usr/local/bin, etc.):\n\njulia --project=. -e 'using Pkg; Pkg.add(\"MPIPreferences\"); using MPIPreferences; MPIPreferences.use_system_binary()'","category":"section"},{"location":"tutorials/running-jexpresso/#Manual-Configuration-(For-Multiple-MPI-Installations-or-MPI-not-in-Default-Path)","page":"-","title":"Manual Configuration (For Multiple MPI Installations or MPI not in Default Path)","text":"For MPI installations in non-standard locations (e.g., /opt/openmpi, or custom paths):\n\njulia --project=. -e 'using Pkg; Pkg.add(\"MPIPreferences\"); using MPIPreferences; MPIPreferences.use_system_binary(;extra_paths = [\"/where/your/mpi/lib\"])'\n\nIf MPI is installed via homebrew on macOS, the MPI lib path is:\n\n/opt/homebrew/lib","category":"section"},{"location":"tutorials/running-jexpresso/#3.-Running-with-MPI","page":"-","title":"3. Running with MPI","text":"","category":"section"},{"location":"tutorials/running-jexpresso/#Basic-Execution","page":"-","title":"Basic Execution","text":"mpiexec -n <NPROCS> julia --project=. -e 'push!(empty!(ARGS), \"<EQUATIONS>\", \"<CASE_NAME>\"); include(\"./src/Jexpresso.jl\")'","category":"section"},{"location":"tutorials/running-jexpresso/#Implementation-Specific-Examples","page":"-","title":"Implementation-Specific Examples","text":"mpiexec -n 4 julia --project=. -e 'push!(empty!(ARGS), \"CompEuler\", \"3d\"); include(\"./src/Jexpresso.jl\")'","category":"section"},{"location":"tutorials/running-jexpresso/#Troubleshooting","page":"-","title":"Troubleshooting","text":"Library conflicts: Clear existing preferences:\nrm -f LocalPreferences.toml\nPath issues: Verify paths with:\nwhich mpiexec\nwhich mpirun\nYou may have to use the full aboslute path to mpiexec or mpirun and to julia like this if necessary:\n/opt/homebrew/Cellar/open-mpi/5.0.6/bin/mpirun -n 4 /Applications/Julia-1.11.app/Contents/Resources/julia/bin/julia --project=. -e 'push!(empty!(ARGS), \"CompEuler\", \"theta\"); include(\"./src/Jexpresso.jl\")'\n\nVersion mismatches: Ensure consistent versions:\nmpicc --version\nmpif90 --version","category":"section"},{"location":"#Jexpresso.jl","page":"Home","title":"Jexpresso.jl","text":"Documentation of Jexpresso.jl.\n\nnote: Note\nThis documentation is and will always be WIP!","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"Jexpresso is a CPU/GPU research software for the numerical solution of a system of arbitrary conservation laws in 1D, 2D, 3D using continuous spectral elements (SEM). Nevertheless, the code is built so that any other numerical method can be added. For example, the Jexpresso already contains a 1D finite difference implementation as well.\n\nJexpresso is written in the Julia programming language and was thought to be modular and allow any user to add any equations in any dimensions without knowing anything about numerical methods. ","category":"section"},{"location":"#Do-I-need-to-know-Julia-to-use-Jexpresso?","page":"Home","title":"Do I need to know Julia to use Jexpresso?","text":"Yes and no. It depends how much you are interested in adding your own equation set in the code rather than using it as a black box. \n\nThe following are useful resources about Julia:\n\nJulia webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning\n\nPages = [\n  \"Jexpresso.md\",\n  ]","category":"section"},{"location":"#Equations:","page":"Home","title":"Equations:","text":"Jexpresso uses arbitrarily high-order (3rd and above) continuous spectral elements to solve\n\nfracpartial bf qpartial t + sum_i=1^ndnablacdotbf F_i(bf q) = munabla^2bf q + bf S(bf q) + rm bc\n\nwhere the vectors bf q, bf F, and bf S are problem-dependent as shown below, and are taken to be zero vectors of the appropriate size when not explicitly stated otherwise.\n\nThe Julia package DifferentialEquations.jl is used for time discretization and stepping.\n\nIn order, we provide tests and results for the following equations:\n\n1D wave equation:\n\nbf q=beginbmatrix\nu \nv\nendbmatrixquad bf F=beginbmatrix\nv\nu\nendbmatrix\n\n2: 1D shallow water:\n\nbf q=beginbmatrix\nh \nu\nendbmatrixquad bf F=beginbmatrix\nUh + Hu\ngh + Uu\nendbmatrix\n\nwhere H and U are a reference height and velocity, respectively.\n\n2D Helmholtz:\n\nbf S=beginbmatrix\nalpha^2 u + f(xz)\nendbmatrixquad munabla^2bf q=mubeginbmatrix\nu_xx + u_zz\nendbmatrix\n\nfor a constant value of alpha and mu, which are case-dependent.\n\n2D scalar advection-diffusion:\n\nbf q=beginbmatrix\nq\nendbmatrixquad bf F=beginbmatrix\nqu\nendbmatrixquad bf F=beginbmatrix\nqv\nendbmatrixquad munabla^2bf q=mubeginbmatrix\nq_xx + q_zz\nendbmatrix\n\n2D Euler equations of compressible flows with gravity and N passive chemicals c_i forall i=1N \n\nbf q=beginbmatrix\nrho \nrho u\nrho v\nrho theta\nrho c1\n\nrho cN\nendbmatrixquad bf F1=beginbmatrix\nrho u\nrho u^2 + p\nrho u v\nrho u theta\nrho u c1\n\nrho u cN\nendbmatrixquad bf F2=beginbmatrix\nrho v\nrho v u\nrho v^2 + p\nrho v theta\nrho v c1\n\nrho v cN\nendbmatrixquad bf S=beginbmatrix\n0\n0\n-rho g\n0\n0\n\n0\nendbmatrixquad munabla^2bf q=mubeginbmatrix\n0\nu_xx + u_zz\nv_xx + v_zz\ntheta_xx + theta_zz\nc1_xx + c1_zz\n\ncN_xx + cN_zz\nendbmatrix\n\nThe equation of state for a perfect gas is used to close the system.\n\n3D Euler equations of compressible flows with gravity\n\nbf q=beginbmatrix\nrho \nrho u\nrho v\nrho w\nrho theta\nendbmatrixquad bf F1=beginbmatrix\nrho u\nrho u^2 + p\nrho u v\nrho u w\nrho u theta\nendbmatrixquad bf F2=beginbmatrix\nrho v\nrho v u\nrho v^2 + p\nrho v w\nrho v theta\nendbmatrixquad bf F3=beginbmatrix\nrho w\nrho w u\nrho w v\nrho w^2 + p\nrho w theta\nendbmatrixquad bf S=beginbmatrix\n0\n0\n0\n-rho g\n0\nendbmatrixquad munabla^2bf q=mubeginbmatrix\n0\nu_xx + u_yy + u_zz\nv_xx + v_yy + v_zz\nw_xx + w_yy + w_zz\ntheta_xx + theta_yy + theta_zz\nendbmatrix\n\nIf you are interested in contributing, please get in touch: Simone Marras, Yassine Tissaoui","category":"section"},{"location":"#Some-notes-on-using-JEXPRESSO","page":"Home","title":"Some notes on using JEXPRESSO","text":"To install and run the code assume Julia 1.11.0","category":"section"},{"location":"#Setup-with-CPUs-on-one-core-from-the-Julia-REPL:","page":"Home","title":"Setup with CPUs on one core from the Julia REPL:","text":"cd $JEXPRESSO_HOME\njulia --project=. -e \"using Pkg; Pkg.instantiate(); Pkg.API.precompile()\"\n\nfollowed by the following:\n\nPush problem name to ARGS You need to do this only when you run a new problem\n\npush!(empty!(ARGS), EQUATIONS::String, EQUATIONS_CASE_NAME::String);\ninclude(\"./src/Jexpresso.jl\")\n\nPROBLEMNAME is the name of your problem directory as JEXPRESSO/problems/equations/problemname\nPROBLEMCASENAME is the name of the subdirectory containing the specific setup that you want to run: \n\nThe path would look like  $JEXPRESSO/problems/equations/PROBLEM_NAME/PROBLEM_CASE_NAME","category":"section"},{"location":"#Setup-an-MPI-run:","page":"Home","title":"Setup an MPI run:","text":"Basic Execution\n\nmpiexec -n <NPROCS> julia --project=. -e 'push!(empty!(ARGS), \"<EQUATIONS>\", \"<CASE_NAME>\"); include(\"./src/Jexpresso.jl\")'\n\nImplementation-Specific Examples\n\nmpiexec -n 4 julia --project=. -e 'push!(empty!(ARGS), \"CompEuler\", \"3d\"); include(\"./src/Jexpresso.jl\")'","category":"section"},{"location":"#Troubleshooting","page":"Home","title":"Troubleshooting","text":"Library conflicts: Clear existing preferences:\nrm -f LocalPreferences.toml\nPath issues: Verify paths with:\nwhich mpiexec\nwhich mpirun\nYou may have to use the full aboslute path to mpiexec or mpirun and to julia like this if necessary. For example, if your mpirun lives in /opt/homebrew/Cellar/open-mpi/5.0.6/bin/mpirun, then you may want to run the code with the full path like this:\n/opt/homebrew/Cellar/open-mpi/5.0.6/bin/mpirun -n 4 /Applications/Julia-1.11.app/Contents/Resources/julia/bin/julia --project=. -e 'push!(empty!(ARGS), \"CompEuler\", \"theta\"); include(\"./src/Jexpresso.jl\")'\nImportant notice: you need to use the Julia version that is correctly linked to the same MPI installation.\n\nIf you have multiple Julia installations on your machine, use the full path to the one linked to the mpirun at hand.\n\nVersion mismatches: Ensure consistent versions:\nmpicc --version\nmpif90 --version","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"Jexpresso leverages the properties of the Julia language to make it as fast as a compiled code. Some performance, measured against a legacy and massive Fortran 90/Modern Fortran code, are shown in page ``@contents Pages = [     \"features/performance.md\", ]","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"The following tutorials will introduce you to the functionality of Jexpresso.jl.\n\nPages = [\n    \"tutorials/user_inputs.md\",\n    \"tutorials/theta.md\",\n    \"tutorials/define_output_variables.md\",\n    \"tutorials/laguerre_paper.md\",\n    ]\nDepth = 2","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"Pages = [\n          Jexpresso.md\",\n     ]","category":"section"}]
}
